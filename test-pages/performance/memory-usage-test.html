<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Usage Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .memory-chart { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 20px; margin: 20px 0; }
        .memory-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .stat { text-align: center; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd; }
        .controls { margin: 20px 0; }
        .controls button { margin: 5px; padding: 10px 15px; border: none; background: #17a2b8; color: white; border-radius: 4px; cursor: pointer; }
        .test-widgets { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0; }
        .widget-container { min-height: 200px; border: 1px solid #ccc; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>E1 Calculator Memory Usage Test</h1>
    <p>This page monitors memory consumption during widget operations.</p>
    
    <div class="memory-chart">
        <h3>Memory Statistics</h3>
        <div class="memory-stats" id="memory-stats">
            <div class="stat">
                <strong>Baseline</strong>
                <div id="baseline-memory">Loading...</div>
            </div>
            <div class="stat">
                <strong>Current Usage</strong>
                <div id="current-memory">Loading...</div>
            </div>
            <div class="stat">
                <strong>Widget Memory</strong>
                <div id="widget-memory">0 MB</div>
            </div>
            <div class="stat">
                <strong>DOM Nodes</strong>
                <div id="dom-nodes">0</div>
            </div>
            <div class="stat">
                <strong>Event Listeners</strong>
                <div id="event-listeners">0</div>
            </div>
            <div class="stat">
                <strong>Memory Leaks</strong>
                <div id="memory-leaks">None</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="measureBaseline()">Measure Baseline</button>
        <button onclick="addWidget()">Add Widget</button>
        <button onclick="removeWidget()">Remove Widget</button>
        <button onclick="addMultipleWidgets()">Add 5 Widgets</button>
        <button onclick="removeAllWidgets()">Remove All</button>
        <button onclick="forceGC()">Force Garbage Collection</button>
        <button onclick="runMemoryLeakTest()">Test Memory Leaks</button>
    </div>
    
    <div class="test-widgets" id="test-widgets">
        <!-- Dynamic widgets will be added here -->
    </div>
    
    <div id="memory-log" style="background: #f5f5f5; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></div>
    
    <script src="../../dist/e1-calculator-widget.min.js"></script>
    <script>
        let memoryData = {
            baseline: 0,
            widgetCount: 0,
            domNodesBefore: 0,
            measurements: []
        };
        
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('memory-log');
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function getMemoryUsage() {
            if (performance.memory) {
                return {
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                };
            }
            return null;
        }
        
        function updateMemoryDisplay() {
            const memory = getMemoryUsage();
            if (memory) {
                const currentMB = Math.round(memory.used / 1024 / 1024);
                const widgetMemory = memoryData.baseline > 0 ? 
                    Math.round((memory.used - memoryData.baseline) / 1024 / 1024) : 0;
                
                document.getElementById('current-memory').textContent = currentMB + ' MB';
                document.getElementById('widget-memory').textContent = Math.max(0, widgetMemory) + ' MB';
                
                // Update DOM nodes count
                const domNodes = document.querySelectorAll('*').length;
                document.getElementById('dom-nodes').textContent = domNodes;
            }
            
            // Update widget count display
            document.getElementById('event-listeners').textContent = memoryData.widgetCount * 10 + ' (est.)';
        }
        
        function measureBaseline() {
            const memory = getMemoryUsage();
            if (memory) {
                memoryData.baseline = memory.used;
                const baselineMB = Math.round(memory.used / 1024 / 1024);
                document.getElementById('baseline-memory').textContent = baselineMB + ' MB';
                log(`Baseline memory: ${baselineMB}MB`);
            } else {
                log('Memory API not available in this browser');
            }
            updateMemoryDisplay();
        }
        
        async function addWidget() {
            const widgetId = `memory-test-widget-${Date.now()}`;
            const container = document.createElement('div');
            container.id = widgetId;
            container.className = 'widget-container';
            container.setAttribute('data-e1-calculator', '');
            
            document.getElementById('test-widgets').appendChild(container);
            
            const memoryBefore = getMemoryUsage();
            
            try {
                const instance = await window.E1Calculator.init(widgetId);
                memoryData.widgetCount++;
                
                const memoryAfter = getMemoryUsage();
                if (memoryBefore && memoryAfter) {
                    const memoryDiff = Math.round((memoryAfter.used - memoryBefore.used) / 1024);
                    log(`Widget added: +${memoryDiff}KB memory`);
                }
                
                updateMemoryDisplay();
                
            } catch (error) {
                log('Failed to add widget: ' + error.message);
                container.remove();
            }
        }
        
        function removeWidget() {
            const widgets = document.querySelectorAll('#test-widgets [data-e1-calculator]');
            if (widgets.length > 0) {
                const lastWidget = widgets[widgets.length - 1];
                const widgetId = lastWidget.id;
                
                const memoryBefore = getMemoryUsage();
                
                // Destroy widget instance
                if (window.E1Calculator) {
                    window.E1Calculator.destroy(widgetId);
                }
                
                // Remove DOM element
                lastWidget.remove();
                memoryData.widgetCount = Math.max(0, memoryData.widgetCount - 1);
                
                // Force garbage collection if possible
                setTimeout(() => {
                    const memoryAfter = getMemoryUsage();
                    if (memoryBefore && memoryAfter) {
                        const memoryDiff = Math.round((memoryBefore.used - memoryAfter.used) / 1024);
                        log(`Widget removed: -${memoryDiff}KB memory`);
                    }
                    updateMemoryDisplay();
                }, 100);
            }
        }
        
        async function addMultipleWidgets() {
            log('Adding 5 widgets...');
            const memoryBefore = getMemoryUsage();
            
            for (let i = 0; i < 5; i++) {
                await addWidget();
                // Small delay to allow memory measurement
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const memoryAfter = getMemoryUsage();
            if (memoryBefore && memoryAfter) {
                const totalIncrease = Math.round((memoryAfter.used - memoryBefore.used) / 1024);
                const avgPerWidget = Math.round(totalIncrease / 5);
                log(`5 widgets added: +${totalIncrease}KB total, ~${avgPerWidget}KB per widget`);
            }
        }
        
        function removeAllWidgets() {
            log('Removing all widgets...');
            const memoryBefore = getMemoryUsage();
            
            // Destroy all widget instances
            if (window.E1Calculator) {
                window.E1Calculator.destroyAll();
            }
            
            // Remove all DOM elements
            const testContainer = document.getElementById('test-widgets');
            testContainer.innerHTML = '';
            memoryData.widgetCount = 0;
            
            setTimeout(() => {
                const memoryAfter = getMemoryUsage();
                if (memoryBefore && memoryAfter) {
                    const memoryFreed = Math.round((memoryBefore.used - memoryAfter.used) / 1024);
                    log(`All widgets removed: -${memoryFreed}KB memory freed`);
                }
                updateMemoryDisplay();
            }, 200);
        }
        
        function forceGC() {
            if (window.gc) {
                window.gc();
                log('Garbage collection forced');
            } else {
                log('Garbage collection not available (run Chrome with --expose-gc for testing)');
            }
            
            setTimeout(updateMemoryDisplay, 100);
        }
        
        async function runMemoryLeakTest() {
            log('Running memory leak test...');
            
            const iterations = 10;
            const memoryReadings = [];
            
            for (let i = 0; i < iterations; i++) {
                // Add widgets
                await addMultipleWidgets();
                
                // Record memory
                const memory = getMemoryUsage();
                if (memory) {
                    memoryReadings.push(memory.used);
                }
                
                // Remove widgets
                removeAllWidgets();
                
                // Wait for cleanup
                await new Promise(resolve => setTimeout(resolve, 500));
                
                log(`Iteration ${i + 1}/${iterations} completed`);
            }
            
            // Analyze results
            if (memoryReadings.length > 0) {
                const initialMemory = memoryReadings[0];
                const finalMemory = memoryReadings[memoryReadings.length - 1];
                const memoryGrowth = finalMemory - initialMemory;
                const growthMB = Math.round(memoryGrowth / 1024 / 1024);
                
                if (growthMB > 5) {
                    document.getElementById('memory-leaks').textContent = `Possible leak: +${growthMB}MB`;
                    log(`Memory leak detected: ${growthMB}MB growth over ${iterations} iterations`);
                } else {
                    document.getElementById('memory-leaks').textContent = 'None detected';
                    log(`No significant memory leaks detected (${growthMB}MB growth is within normal range)`);
                }
            }
        }
        
        // Auto-measure baseline on load
        window.addEventListener('load', () => {
            setTimeout(measureBaseline, 1000);
            
            // Update memory display every 2 seconds
            setInterval(updateMemoryDisplay, 2000);
        });
    </script>
</body>
</html>