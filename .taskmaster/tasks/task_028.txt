/**
 * TASK: Implement Visual Support Component with Cloudflare Images Integration
 * 
 * OBJECTIVE:
 * Create a visual support system that displays contextual images/guides based on 
 * the currently active form section/field. Integrate with Cloudflare Images for 
 * optimized image delivery and automatic variant generation.
 * 
 * REQUIREMENTS:
 * 1. Visual Support Component that responds to form focus events
 * 2. Cloudflare Images integration for image upload, processing, and CDN delivery
 * 3. Database integration with Supabase for storing image metadata
 * 4. Automatic variant generation (thumbnail, mobile, desktop, original)
 * 5. Admin interface for managing visual assets
 * 6. Dynamic image loading based on form context
 * 
 * IMPLEMENTATION STEPS:
 * 1. Set up Cloudflare Images account and API credentials
 * 2. Create image upload endpoint that forwards to Cloudflare
 * 3. Store image IDs and metadata in Supabase
 * 4. Build VisualSupport component that fetches relevant images
 * 5. Integrate with FormRenderer for context awareness
 * 6. Add admin UI for image management
 */

// ============================================
// ENVIRONMENT VARIABLES NEEDED (.env.local)
// ============================================
/*
CLOUDFLARE_ACCOUNT_ID=your_account_id
CLOUDFLARE_IMAGES_API_TOKEN=your_api_token
NEXT_PUBLIC_CLOUDFLARE_ACCOUNT_HASH=your_account_hash
*/

// ============================================
// 1. CLOUDFLARE IMAGES CLIENT
// ============================================

// lib/cloudflare-images.ts
interface CloudflareImageVariant {
  thumbnail: string;  // 150x150
  mobile: string;     // 768px width
  desktop: string;    // 1920px width
  original: string;   // Original size
}

interface CloudflareUploadResponse {
  id: string;
  filename: string;
  uploaded: string;
  requireSignedURLs: boolean;
  variants: string[];
}

export class CloudflareImagesClient {
  private accountId: string;
  private apiToken: string;
  private accountHash: string;
  private baseUrl: string;

  constructor() {
    this.accountId = process.env.CLOUDFLARE_ACCOUNT_ID!;
    this.apiToken = process.env.CLOUDFLARE_IMAGES_API_TOKEN!;
    this.accountHash = process.env.NEXT_PUBLIC_CLOUDFLARE_ACCOUNT_HASH!;
    this.baseUrl = `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/images/v1`;
  }

  async uploadImage(
    file: File | Blob,
    metadata?: Record<string, string>
  ): Promise<CloudflareUploadResponse> {
    const formData = new FormData();
    formData.append('file', file);
    
    if (metadata) {
      formData.append('metadata', JSON.stringify(metadata));
    }

    const response = await fetch(this.baseUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiToken}`,
      },
      body: formData,
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Cloudflare upload failed: ${error.errors?.[0]?.message || response.statusText}`);
    }

    const data = await response.json();
    return data.result;
  }

  getImageUrl(imageId: string, variant: keyof CloudflareImageVariant = 'original'): string {
    return `https://imagedelivery.net/${this.accountHash}/${imageId}/${variant}`;
  }

  getImageUrls(imageId: string): CloudflareImageVariant {
    return {
      thumbnail: this.getImageUrl(imageId, 'thumbnail'),
      mobile: this.getImageUrl(imageId, 'mobile'),
      desktop: this.getImageUrl(imageId, 'desktop'),
      original: this.getImageUrl(imageId, 'original'),
    };
  }

  async deleteImage(imageId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/${imageId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${this.apiToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to delete image: ${response.statusText}`);
    }
  }
}

// ============================================
// 2. DATABASE SCHEMA FOR VISUAL ASSETS
// ============================================

// types/visual-asset.types.ts
export interface VisualAsset {
  id: string;
  cloudflare_image_id: string;
  section_id: string;
  field_id?: string;
  asset_type: 'default' | 'field_specific' | 'help_diagram' | 'tooltip';
  title: string;
  description?: string;
  help_text?: string;
  display_order: number;
  created_at: string;
  updated_at: string;
}

// Supabase migration: create_visual_assets_table.sql
/*
CREATE TABLE visual_assets (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cloudflare_image_id VARCHAR(255) NOT NULL,
  section_id VARCHAR(100) NOT NULL,
  field_id VARCHAR(100),
  asset_type VARCHAR(50) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  help_text TEXT,
  display_order INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  INDEX idx_section_field (section_id, field_id),
  INDEX idx_display_order (display_order)
);
*/

// ============================================
// 3. API ENDPOINTS
// ============================================

// app/api/admin/visual-assets/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { CloudflareImagesClient } from '@/lib/cloudflare-images';
import { createClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  try {
    // Check admin authentication
    const supabase = createClient();
    
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const sectionId = formData.get('sectionId') as string;
    const fieldId = formData.get('fieldId') as string | null;
    const assetType = formData.get('assetType') as string;
    const title = formData.get('title') as string;
    const description = formData.get('description') as string | null;
    const helpText = formData.get('helpText') as string | null;

    if (!file || !sectionId || !assetType || !title) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Upload to Cloudflare
    const cloudflare = new CloudflareImagesClient();
    const uploadResult = await cloudflare.uploadImage(file, {
      sectionId,
      fieldId: fieldId || '',
      assetType,
    });

    // Save metadata to Supabase
    const { data, error } = await supabase
      .from('visual_assets')
      .insert({
        cloudflare_image_id: uploadResult.id,
        section_id: sectionId,
        field_id: fieldId,
        asset_type: assetType,
        title,
        description,
        help_text: helpText,
      })
      .select()
      .single();

    if (error) {
      // Rollback: Delete from Cloudflare if database insert fails
      await cloudflare.deleteImage(uploadResult.id);
      throw error;
    }

    return NextResponse.json({
      success: true,
      asset: data,
      urls: cloudflare.getImageUrls(uploadResult.id),
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// app/api/visual-assets/[sectionId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { CloudflareImagesClient } from '@/lib/cloudflare-images';

export async function GET(
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) {
  try {
    const supabase = createClient();
    const { sectionId } = params;
    const fieldId = request.nextUrl.searchParams.get('fieldId');

    let query = supabase
      .from('visual_assets')
      .select('*')
      .eq('section_id', sectionId)
      .order('display_order');

    if (fieldId) {
      query = query.eq('field_id', fieldId);
    } else {
      query = query.is('field_id', null);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Add Cloudflare URLs to each asset
    const cloudflare = new CloudflareImagesClient();
    const assetsWithUrls = data.map(asset => ({
      ...asset,
      urls: cloudflare.getImageUrls(asset.cloudflare_image_id),
    }));

    return NextResponse.json(assetsWithUrls);
  } catch (error) {
    console.error('Fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch visual assets' },
      { status: 500 }
    );
  }
}

// ============================================
// 4. VISUAL SUPPORT COMPONENT
// ============================================

// components/VisualSupport.tsx
import React, { useState, useEffect } from 'react';
import { VisualAsset } from '@/types/visual-asset.types';

interface VisualSupportProps {
  activeSection: string | null;
  activeField: string | null;
  className?: string;
}

export const VisualSupport: React.FC<VisualSupportProps> = ({
  activeSection,
  activeField,
  className = '',
}) => {
  const [assets, setAssets] = useState<(VisualAsset & { urls: any })[]>([]);
  const [loading, setLoading] = useState(false);
  const [currentAsset, setCurrentAsset] = useState<(VisualAsset & { urls: any }) | null>(null);

  // Fetch assets when section or field changes
  useEffect(() => {
    if (!activeSection) {
      setAssets([]);
      setCurrentAsset(null);
      return;
    }

    const fetchAssets = async () => {
      setLoading(true);
      try {
        const url = `/api/visual-assets/${activeSection}${
          activeField ? `?fieldId=${activeField}` : ''
        }`;
        const response = await fetch(url);
        const data = await response.json();
        
        setAssets(data);
        if (data.length > 0) {
          setCurrentAsset(data[0]); // Set first asset as current
        }
      } catch (error) {
        console.error('Failed to fetch visual assets:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchAssets();
  }, [activeSection, activeField]);

  // Determine which image variant to use based on screen size
  const getResponsiveImageUrl = () => {
    if (!currentAsset) return null;
    
    // You could use a resize observer or media queries here
    const isMobile = window.innerWidth < 768;
    const isTablet = window.innerWidth < 1024;
    
    if (isMobile) return currentAsset.urls.mobile;
    if (isTablet) return currentAsset.urls.desktop;
    return currentAsset.urls.desktop;
  };

  if (!activeSection || !currentAsset) {
    return (
      <div className={`flex items-center justify-center h-full bg-gray-50 ${className}`}>
        <div className="text-center p-8">
          <svg className="w-24 h-24 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} 
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
          <p className="text-gray-500">Täytä lomake nähdäksesi visuaalisen oppaan</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className={`flex items-center justify-center h-full bg-gray-50 ${className}`}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <div className={`flex flex-col h-full bg-white ${className}`}>
      {/* Main Image */}
      <div className="relative h-1/2 bg-gray-100">
        <img
          src={getResponsiveImageUrl()}
          alt={currentAsset.title}
          className="w-full h-full object-cover"
          loading="lazy"
        />
        
        {/* Image Overlay */}
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-6">
          <h2 className="text-white text-2xl font-bold">{currentAsset.title}</h2>
          {currentAsset.description && (
            <p className="text-white/90 text-sm mt-1">{currentAsset.description}</p>
          )}
        </div>
      </div>

      {/* Help Content */}
      <div className="flex-1 overflow-y-auto p-6">
        {currentAsset.help_text && (
          <div className="mb-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r">
            <p className="text-sm text-blue-900">{currentAsset.help_text}</p>
          </div>
        )}

        {/* Additional assets as thumbnails */}
        {assets.length > 1 && (
          <div className="mt-6">
            <h3 className="text-sm font-semibold text-gray-700 mb-3">Lisää kuvia:</h3>
            <div className="grid grid-cols-3 gap-2">
              {assets.map((asset, index) => (
                <button
                  key={asset.id}
                  onClick={() => setCurrentAsset(asset)}
                  className={`relative rounded overflow-hidden border-2 ${
                    currentAsset.id === asset.id ? 'border-blue-500' : 'border-gray-200'
                  }`}
                >
                  <img
                    src={asset.urls.thumbnail}
                    alt={asset.title}
                    className="w-full h-20 object-cover"
                  />
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// ============================================
// 5. INTEGRATION WITH FORM RENDERER
// ============================================

// components/CalculatorLayout.tsx
import React, { useState } from 'react';
import { VisualSupport } from './VisualSupport';
import { FormRenderer } from './FormRenderer';

export const CalculatorLayout: React.FC = () => {
  const [activeSection, setActiveSection] = useState<string | null>(null);
  const [activeField, setActiveField] = useState<string | null>(null);

  return (
    <div className="flex h-screen">
      {/* Visual Support Panel - 40% width */}
      <div className="w-2/5 border-r">
        <VisualSupport
          activeSection={activeSection}
          activeField={activeField}
          className="h-full"
        />
      </div>

      {/* Form Panel - 60% width */}
      <div className="flex-1 overflow-y-auto bg-gray-50">
        <FormRenderer
          onSectionFocus={setActiveSection}
          onFieldFocus={setActiveField}
        />
      </div>
    </div>
  );
};

// ============================================
// 6. ADMIN INTERFACE FOR IMAGE MANAGEMENT
// ============================================

// components/admin/VisualAssetManager.tsx
import React, { useState } from 'react';

interface VisualAssetManagerProps {
  sectionId: string;
  fieldId?: string;
}

export const VisualAssetManager: React.FC<VisualAssetManagerProps> = ({
  sectionId,
  fieldId,
}) => {
  const [uploading, setUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [helpText, setHelpText] = useState('');

  const handleUpload = async () => {
    if (!selectedFile || !title) {
      alert('Please select a file and provide a title');
      return;
    }

    setUploading(true);
    const formData = new FormData();
    formData.append('file', selectedFile);
    formData.append('sectionId', sectionId);
    if (fieldId) formData.append('fieldId', fieldId);
    formData.append('assetType', fieldId ? 'field_specific' : 'default');
    formData.append('title', title);
    formData.append('description', description);
    formData.append('helpText', helpText);

    try {
      const response = await fetch('/api/admin/visual-assets/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) throw new Error('Upload failed');

      const result = await response.json();
      console.log('Upload successful:', result);
      
      // Reset form
      setSelectedFile(null);
      setTitle('');
      setDescription('');
      setHelpText('');
      
      // Refresh assets list (implement this based on your needs)
    } catch (error) {
      console.error('Upload error:', error);
      alert('Failed to upload image');
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Upload Visual Asset</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Image File
          </label>
          <input
            type="file"
            accept="image/*"
            onChange={(e) => setSelectedFile(e.target.files?.[0] || null)}
            className="w-full"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Title *
          </label>
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            placeholder="e.g., How to measure ceiling height"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Description
          </label>
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            rows={2}
            placeholder="Brief description of the image"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Help Text
          </label>
          <textarea
            value={helpText}
            onChange={(e) => setHelpText(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            rows={3}
            placeholder="Detailed help text to display with the image"
          />
        </div>

        <button
          onClick={handleUpload}
          disabled={uploading || !selectedFile || !title}
          className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {uploading ? 'Uploading...' : 'Upload Image'}
        </button>
      </div>
    </div>
  );
};